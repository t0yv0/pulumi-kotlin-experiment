// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.storage.outputs;

import com.pulumi.azurenative.storage.outputs.AzureFilesIdentityBasedAuthenticationResponse;
import com.pulumi.azurenative.storage.outputs.BlobRestoreStatusResponse;
import com.pulumi.azurenative.storage.outputs.CustomDomainResponse;
import com.pulumi.azurenative.storage.outputs.EncryptionResponse;
import com.pulumi.azurenative.storage.outputs.EndpointsResponse;
import com.pulumi.azurenative.storage.outputs.ExtendedLocationResponse;
import com.pulumi.azurenative.storage.outputs.GeoReplicationStatsResponse;
import com.pulumi.azurenative.storage.outputs.IdentityResponse;
import com.pulumi.azurenative.storage.outputs.KeyCreationTimeResponse;
import com.pulumi.azurenative.storage.outputs.KeyPolicyResponse;
import com.pulumi.azurenative.storage.outputs.NetworkRuleSetResponse;
import com.pulumi.azurenative.storage.outputs.PrivateEndpointConnectionResponse;
import com.pulumi.azurenative.storage.outputs.RoutingPreferenceResponse;
import com.pulumi.azurenative.storage.outputs.SasPolicyResponse;
import com.pulumi.azurenative.storage.outputs.SkuResponse;
import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetStorageAccountResult {
    /**
     * @return Required for storage accounts where kind = BlobStorage. The access tier used for billing.
     * 
     */
    private String accessTier;
    /**
     * @return Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true for this property.
     * 
     */
    private @Nullable Boolean allowBlobPublicAccess;
    /**
     * @return Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). The default value is null, which is equivalent to true.
     * 
     */
    private @Nullable Boolean allowSharedKeyAccess;
    /**
     * @return Provides the identity based authentication settings for Azure Files.
     * 
     */
    private @Nullable AzureFilesIdentityBasedAuthenticationResponse azureFilesIdentityBasedAuthentication;
    /**
     * @return Blob restore status
     * 
     */
    private BlobRestoreStatusResponse blobRestoreStatus;
    /**
     * @return Gets the creation date and time of the storage account in UTC.
     * 
     */
    private String creationTime;
    /**
     * @return Gets the custom domain the user assigned to this storage account.
     * 
     */
    private CustomDomainResponse customDomain;
    /**
     * @return Allows https traffic only to storage service if sets to true.
     * 
     */
    private @Nullable Boolean enableHttpsTrafficOnly;
    /**
     * @return NFS 3.0 protocol support enabled if set to true.
     * 
     */
    private @Nullable Boolean enableNfsV3;
    /**
     * @return Gets the encryption settings on the account. If unspecified, the account is unencrypted.
     * 
     */
    private EncryptionResponse encryption;
    /**
     * @return The extendedLocation of the resource.
     * 
     */
    private @Nullable ExtendedLocationResponse extendedLocation;
    /**
     * @return If the failover is in progress, the value will be true, otherwise, it will be null.
     * 
     */
    private Boolean failoverInProgress;
    /**
     * @return Geo Replication Stats
     * 
     */
    private GeoReplicationStatsResponse geoReplicationStats;
    /**
     * @return Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
     * 
     */
    private String id;
    /**
     * @return The identity of the resource.
     * 
     */
    private @Nullable IdentityResponse identity;
    /**
     * @return Account HierarchicalNamespace enabled if sets to true.
     * 
     */
    private @Nullable Boolean isHnsEnabled;
    /**
     * @return Storage account keys creation time.
     * 
     */
    private KeyCreationTimeResponse keyCreationTime;
    /**
     * @return KeyPolicy assigned to the storage account.
     * 
     */
    private KeyPolicyResponse keyPolicy;
    /**
     * @return Gets the Kind.
     * 
     */
    private String kind;
    /**
     * @return Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
     * 
     */
    private @Nullable String largeFileSharesState;
    /**
     * @return Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
     * 
     */
    private String lastGeoFailoverTime;
    /**
     * @return The geo-location where the resource lives
     * 
     */
    private String location;
    /**
     * @return Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
     * 
     */
    private @Nullable String minimumTlsVersion;
    /**
     * @return The name of the resource
     * 
     */
    private String name;
    /**
     * @return Network rule set
     * 
     */
    private NetworkRuleSetResponse networkRuleSet;
    /**
     * @return Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object. Note that Standard_ZRS and Premium_LRS accounts only return the blob endpoint.
     * 
     */
    private EndpointsResponse primaryEndpoints;
    /**
     * @return Gets the location of the primary data center for the storage account.
     * 
     */
    private String primaryLocation;
    /**
     * @return List of private endpoint connection associated with the specified storage account
     * 
     */
    private List<PrivateEndpointConnectionResponse> privateEndpointConnections;
    /**
     * @return Gets the status of the storage account at the time the operation was called.
     * 
     */
    private String provisioningState;
    /**
     * @return Maintains information about the network routing choice opted by the user for data transfer
     * 
     */
    private @Nullable RoutingPreferenceResponse routingPreference;
    /**
     * @return SasPolicy assigned to the storage account.
     * 
     */
    private SasPolicyResponse sasPolicy;
    /**
     * @return Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object from the secondary location of the storage account. Only available if the SKU name is Standard_RAGRS.
     * 
     */
    private EndpointsResponse secondaryEndpoints;
    /**
     * @return Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
     * 
     */
    private String secondaryLocation;
    /**
     * @return Gets the SKU.
     * 
     */
    private SkuResponse sku;
    /**
     * @return Gets the status indicating whether the primary location of the storage account is available or unavailable.
     * 
     */
    private String statusOfPrimary;
    /**
     * @return Gets the status indicating whether the secondary location of the storage account is available or unavailable. Only available if the SKU name is Standard_GRS or Standard_RAGRS.
     * 
     */
    private String statusOfSecondary;
    /**
     * @return Resource tags.
     * 
     */
    private @Nullable Map<String,String> tags;
    /**
     * @return The type of the resource. E.g. &#34;Microsoft.Compute/virtualMachines&#34; or &#34;Microsoft.Storage/storageAccounts&#34;
     * 
     */
    private String type;

    private GetStorageAccountResult() {}
    /**
     * @return Required for storage accounts where kind = BlobStorage. The access tier used for billing.
     * 
     */
    public String accessTier() {
        return this.accessTier;
    }
    /**
     * @return Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true for this property.
     * 
     */
    public Optional<Boolean> allowBlobPublicAccess() {
        return Optional.ofNullable(this.allowBlobPublicAccess);
    }
    /**
     * @return Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). The default value is null, which is equivalent to true.
     * 
     */
    public Optional<Boolean> allowSharedKeyAccess() {
        return Optional.ofNullable(this.allowSharedKeyAccess);
    }
    /**
     * @return Provides the identity based authentication settings for Azure Files.
     * 
     */
    public Optional<AzureFilesIdentityBasedAuthenticationResponse> azureFilesIdentityBasedAuthentication() {
        return Optional.ofNullable(this.azureFilesIdentityBasedAuthentication);
    }
    /**
     * @return Blob restore status
     * 
     */
    public BlobRestoreStatusResponse blobRestoreStatus() {
        return this.blobRestoreStatus;
    }
    /**
     * @return Gets the creation date and time of the storage account in UTC.
     * 
     */
    public String creationTime() {
        return this.creationTime;
    }
    /**
     * @return Gets the custom domain the user assigned to this storage account.
     * 
     */
    public CustomDomainResponse customDomain() {
        return this.customDomain;
    }
    /**
     * @return Allows https traffic only to storage service if sets to true.
     * 
     */
    public Optional<Boolean> enableHttpsTrafficOnly() {
        return Optional.ofNullable(this.enableHttpsTrafficOnly);
    }
    /**
     * @return NFS 3.0 protocol support enabled if set to true.
     * 
     */
    public Optional<Boolean> enableNfsV3() {
        return Optional.ofNullable(this.enableNfsV3);
    }
    /**
     * @return Gets the encryption settings on the account. If unspecified, the account is unencrypted.
     * 
     */
    public EncryptionResponse encryption() {
        return this.encryption;
    }
    /**
     * @return The extendedLocation of the resource.
     * 
     */
    public Optional<ExtendedLocationResponse> extendedLocation() {
        return Optional.ofNullable(this.extendedLocation);
    }
    /**
     * @return If the failover is in progress, the value will be true, otherwise, it will be null.
     * 
     */
    public Boolean failoverInProgress() {
        return this.failoverInProgress;
    }
    /**
     * @return Geo Replication Stats
     * 
     */
    public GeoReplicationStatsResponse geoReplicationStats() {
        return this.geoReplicationStats;
    }
    /**
     * @return Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return The identity of the resource.
     * 
     */
    public Optional<IdentityResponse> identity() {
        return Optional.ofNullable(this.identity);
    }
    /**
     * @return Account HierarchicalNamespace enabled if sets to true.
     * 
     */
    public Optional<Boolean> isHnsEnabled() {
        return Optional.ofNullable(this.isHnsEnabled);
    }
    /**
     * @return Storage account keys creation time.
     * 
     */
    public KeyCreationTimeResponse keyCreationTime() {
        return this.keyCreationTime;
    }
    /**
     * @return KeyPolicy assigned to the storage account.
     * 
     */
    public KeyPolicyResponse keyPolicy() {
        return this.keyPolicy;
    }
    /**
     * @return Gets the Kind.
     * 
     */
    public String kind() {
        return this.kind;
    }
    /**
     * @return Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
     * 
     */
    public Optional<String> largeFileSharesState() {
        return Optional.ofNullable(this.largeFileSharesState);
    }
    /**
     * @return Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
     * 
     */
    public String lastGeoFailoverTime() {
        return this.lastGeoFailoverTime;
    }
    /**
     * @return The geo-location where the resource lives
     * 
     */
    public String location() {
        return this.location;
    }
    /**
     * @return Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
     * 
     */
    public Optional<String> minimumTlsVersion() {
        return Optional.ofNullable(this.minimumTlsVersion);
    }
    /**
     * @return The name of the resource
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return Network rule set
     * 
     */
    public NetworkRuleSetResponse networkRuleSet() {
        return this.networkRuleSet;
    }
    /**
     * @return Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object. Note that Standard_ZRS and Premium_LRS accounts only return the blob endpoint.
     * 
     */
    public EndpointsResponse primaryEndpoints() {
        return this.primaryEndpoints;
    }
    /**
     * @return Gets the location of the primary data center for the storage account.
     * 
     */
    public String primaryLocation() {
        return this.primaryLocation;
    }
    /**
     * @return List of private endpoint connection associated with the specified storage account
     * 
     */
    public List<PrivateEndpointConnectionResponse> privateEndpointConnections() {
        return this.privateEndpointConnections;
    }
    /**
     * @return Gets the status of the storage account at the time the operation was called.
     * 
     */
    public String provisioningState() {
        return this.provisioningState;
    }
    /**
     * @return Maintains information about the network routing choice opted by the user for data transfer
     * 
     */
    public Optional<RoutingPreferenceResponse> routingPreference() {
        return Optional.ofNullable(this.routingPreference);
    }
    /**
     * @return SasPolicy assigned to the storage account.
     * 
     */
    public SasPolicyResponse sasPolicy() {
        return this.sasPolicy;
    }
    /**
     * @return Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object from the secondary location of the storage account. Only available if the SKU name is Standard_RAGRS.
     * 
     */
    public EndpointsResponse secondaryEndpoints() {
        return this.secondaryEndpoints;
    }
    /**
     * @return Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
     * 
     */
    public String secondaryLocation() {
        return this.secondaryLocation;
    }
    /**
     * @return Gets the SKU.
     * 
     */
    public SkuResponse sku() {
        return this.sku;
    }
    /**
     * @return Gets the status indicating whether the primary location of the storage account is available or unavailable.
     * 
     */
    public String statusOfPrimary() {
        return this.statusOfPrimary;
    }
    /**
     * @return Gets the status indicating whether the secondary location of the storage account is available or unavailable. Only available if the SKU name is Standard_GRS or Standard_RAGRS.
     * 
     */
    public String statusOfSecondary() {
        return this.statusOfSecondary;
    }
    /**
     * @return Resource tags.
     * 
     */
    public Map<String,String> tags() {
        return this.tags == null ? Map.of() : this.tags;
    }
    /**
     * @return The type of the resource. E.g. &#34;Microsoft.Compute/virtualMachines&#34; or &#34;Microsoft.Storage/storageAccounts&#34;
     * 
     */
    public String type() {
        return this.type;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetStorageAccountResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String accessTier;
        private @Nullable Boolean allowBlobPublicAccess;
        private @Nullable Boolean allowSharedKeyAccess;
        private @Nullable AzureFilesIdentityBasedAuthenticationResponse azureFilesIdentityBasedAuthentication;
        private BlobRestoreStatusResponse blobRestoreStatus;
        private String creationTime;
        private CustomDomainResponse customDomain;
        private @Nullable Boolean enableHttpsTrafficOnly;
        private @Nullable Boolean enableNfsV3;
        private EncryptionResponse encryption;
        private @Nullable ExtendedLocationResponse extendedLocation;
        private Boolean failoverInProgress;
        private GeoReplicationStatsResponse geoReplicationStats;
        private String id;
        private @Nullable IdentityResponse identity;
        private @Nullable Boolean isHnsEnabled;
        private KeyCreationTimeResponse keyCreationTime;
        private KeyPolicyResponse keyPolicy;
        private String kind;
        private @Nullable String largeFileSharesState;
        private String lastGeoFailoverTime;
        private String location;
        private @Nullable String minimumTlsVersion;
        private String name;
        private NetworkRuleSetResponse networkRuleSet;
        private EndpointsResponse primaryEndpoints;
        private String primaryLocation;
        private List<PrivateEndpointConnectionResponse> privateEndpointConnections;
        private String provisioningState;
        private @Nullable RoutingPreferenceResponse routingPreference;
        private SasPolicyResponse sasPolicy;
        private EndpointsResponse secondaryEndpoints;
        private String secondaryLocation;
        private SkuResponse sku;
        private String statusOfPrimary;
        private String statusOfSecondary;
        private @Nullable Map<String,String> tags;
        private String type;
        public Builder() {}
        public Builder(GetStorageAccountResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.accessTier = defaults.accessTier;
    	      this.allowBlobPublicAccess = defaults.allowBlobPublicAccess;
    	      this.allowSharedKeyAccess = defaults.allowSharedKeyAccess;
    	      this.azureFilesIdentityBasedAuthentication = defaults.azureFilesIdentityBasedAuthentication;
    	      this.blobRestoreStatus = defaults.blobRestoreStatus;
    	      this.creationTime = defaults.creationTime;
    	      this.customDomain = defaults.customDomain;
    	      this.enableHttpsTrafficOnly = defaults.enableHttpsTrafficOnly;
    	      this.enableNfsV3 = defaults.enableNfsV3;
    	      this.encryption = defaults.encryption;
    	      this.extendedLocation = defaults.extendedLocation;
    	      this.failoverInProgress = defaults.failoverInProgress;
    	      this.geoReplicationStats = defaults.geoReplicationStats;
    	      this.id = defaults.id;
    	      this.identity = defaults.identity;
    	      this.isHnsEnabled = defaults.isHnsEnabled;
    	      this.keyCreationTime = defaults.keyCreationTime;
    	      this.keyPolicy = defaults.keyPolicy;
    	      this.kind = defaults.kind;
    	      this.largeFileSharesState = defaults.largeFileSharesState;
    	      this.lastGeoFailoverTime = defaults.lastGeoFailoverTime;
    	      this.location = defaults.location;
    	      this.minimumTlsVersion = defaults.minimumTlsVersion;
    	      this.name = defaults.name;
    	      this.networkRuleSet = defaults.networkRuleSet;
    	      this.primaryEndpoints = defaults.primaryEndpoints;
    	      this.primaryLocation = defaults.primaryLocation;
    	      this.privateEndpointConnections = defaults.privateEndpointConnections;
    	      this.provisioningState = defaults.provisioningState;
    	      this.routingPreference = defaults.routingPreference;
    	      this.sasPolicy = defaults.sasPolicy;
    	      this.secondaryEndpoints = defaults.secondaryEndpoints;
    	      this.secondaryLocation = defaults.secondaryLocation;
    	      this.sku = defaults.sku;
    	      this.statusOfPrimary = defaults.statusOfPrimary;
    	      this.statusOfSecondary = defaults.statusOfSecondary;
    	      this.tags = defaults.tags;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder accessTier(String accessTier) {
            this.accessTier = Objects.requireNonNull(accessTier);
            return this;
        }
        @CustomType.Setter
        public Builder allowBlobPublicAccess(@Nullable Boolean allowBlobPublicAccess) {
            this.allowBlobPublicAccess = allowBlobPublicAccess;
            return this;
        }
        @CustomType.Setter
        public Builder allowSharedKeyAccess(@Nullable Boolean allowSharedKeyAccess) {
            this.allowSharedKeyAccess = allowSharedKeyAccess;
            return this;
        }
        @CustomType.Setter
        public Builder azureFilesIdentityBasedAuthentication(@Nullable AzureFilesIdentityBasedAuthenticationResponse azureFilesIdentityBasedAuthentication) {
            this.azureFilesIdentityBasedAuthentication = azureFilesIdentityBasedAuthentication;
            return this;
        }
        @CustomType.Setter
        public Builder blobRestoreStatus(BlobRestoreStatusResponse blobRestoreStatus) {
            this.blobRestoreStatus = Objects.requireNonNull(blobRestoreStatus);
            return this;
        }
        @CustomType.Setter
        public Builder creationTime(String creationTime) {
            this.creationTime = Objects.requireNonNull(creationTime);
            return this;
        }
        @CustomType.Setter
        public Builder customDomain(CustomDomainResponse customDomain) {
            this.customDomain = Objects.requireNonNull(customDomain);
            return this;
        }
        @CustomType.Setter
        public Builder enableHttpsTrafficOnly(@Nullable Boolean enableHttpsTrafficOnly) {
            this.enableHttpsTrafficOnly = enableHttpsTrafficOnly;
            return this;
        }
        @CustomType.Setter
        public Builder enableNfsV3(@Nullable Boolean enableNfsV3) {
            this.enableNfsV3 = enableNfsV3;
            return this;
        }
        @CustomType.Setter
        public Builder encryption(EncryptionResponse encryption) {
            this.encryption = Objects.requireNonNull(encryption);
            return this;
        }
        @CustomType.Setter
        public Builder extendedLocation(@Nullable ExtendedLocationResponse extendedLocation) {
            this.extendedLocation = extendedLocation;
            return this;
        }
        @CustomType.Setter
        public Builder failoverInProgress(Boolean failoverInProgress) {
            this.failoverInProgress = Objects.requireNonNull(failoverInProgress);
            return this;
        }
        @CustomType.Setter
        public Builder geoReplicationStats(GeoReplicationStatsResponse geoReplicationStats) {
            this.geoReplicationStats = Objects.requireNonNull(geoReplicationStats);
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        @CustomType.Setter
        public Builder identity(@Nullable IdentityResponse identity) {
            this.identity = identity;
            return this;
        }
        @CustomType.Setter
        public Builder isHnsEnabled(@Nullable Boolean isHnsEnabled) {
            this.isHnsEnabled = isHnsEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder keyCreationTime(KeyCreationTimeResponse keyCreationTime) {
            this.keyCreationTime = Objects.requireNonNull(keyCreationTime);
            return this;
        }
        @CustomType.Setter
        public Builder keyPolicy(KeyPolicyResponse keyPolicy) {
            this.keyPolicy = Objects.requireNonNull(keyPolicy);
            return this;
        }
        @CustomType.Setter
        public Builder kind(String kind) {
            this.kind = Objects.requireNonNull(kind);
            return this;
        }
        @CustomType.Setter
        public Builder largeFileSharesState(@Nullable String largeFileSharesState) {
            this.largeFileSharesState = largeFileSharesState;
            return this;
        }
        @CustomType.Setter
        public Builder lastGeoFailoverTime(String lastGeoFailoverTime) {
            this.lastGeoFailoverTime = Objects.requireNonNull(lastGeoFailoverTime);
            return this;
        }
        @CustomType.Setter
        public Builder location(String location) {
            this.location = Objects.requireNonNull(location);
            return this;
        }
        @CustomType.Setter
        public Builder minimumTlsVersion(@Nullable String minimumTlsVersion) {
            this.minimumTlsVersion = minimumTlsVersion;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            this.name = Objects.requireNonNull(name);
            return this;
        }
        @CustomType.Setter
        public Builder networkRuleSet(NetworkRuleSetResponse networkRuleSet) {
            this.networkRuleSet = Objects.requireNonNull(networkRuleSet);
            return this;
        }
        @CustomType.Setter
        public Builder primaryEndpoints(EndpointsResponse primaryEndpoints) {
            this.primaryEndpoints = Objects.requireNonNull(primaryEndpoints);
            return this;
        }
        @CustomType.Setter
        public Builder primaryLocation(String primaryLocation) {
            this.primaryLocation = Objects.requireNonNull(primaryLocation);
            return this;
        }
        @CustomType.Setter
        public Builder privateEndpointConnections(List<PrivateEndpointConnectionResponse> privateEndpointConnections) {
            this.privateEndpointConnections = Objects.requireNonNull(privateEndpointConnections);
            return this;
        }
        public Builder privateEndpointConnections(PrivateEndpointConnectionResponse... privateEndpointConnections) {
            return privateEndpointConnections(List.of(privateEndpointConnections));
        }
        @CustomType.Setter
        public Builder provisioningState(String provisioningState) {
            this.provisioningState = Objects.requireNonNull(provisioningState);
            return this;
        }
        @CustomType.Setter
        public Builder routingPreference(@Nullable RoutingPreferenceResponse routingPreference) {
            this.routingPreference = routingPreference;
            return this;
        }
        @CustomType.Setter
        public Builder sasPolicy(SasPolicyResponse sasPolicy) {
            this.sasPolicy = Objects.requireNonNull(sasPolicy);
            return this;
        }
        @CustomType.Setter
        public Builder secondaryEndpoints(EndpointsResponse secondaryEndpoints) {
            this.secondaryEndpoints = Objects.requireNonNull(secondaryEndpoints);
            return this;
        }
        @CustomType.Setter
        public Builder secondaryLocation(String secondaryLocation) {
            this.secondaryLocation = Objects.requireNonNull(secondaryLocation);
            return this;
        }
        @CustomType.Setter
        public Builder sku(SkuResponse sku) {
            this.sku = Objects.requireNonNull(sku);
            return this;
        }
        @CustomType.Setter
        public Builder statusOfPrimary(String statusOfPrimary) {
            this.statusOfPrimary = Objects.requireNonNull(statusOfPrimary);
            return this;
        }
        @CustomType.Setter
        public Builder statusOfSecondary(String statusOfSecondary) {
            this.statusOfSecondary = Objects.requireNonNull(statusOfSecondary);
            return this;
        }
        @CustomType.Setter
        public Builder tags(@Nullable Map<String,String> tags) {
            this.tags = tags;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        public GetStorageAccountResult build() {
            final var o = new GetStorageAccountResult();
            o.accessTier = accessTier;
            o.allowBlobPublicAccess = allowBlobPublicAccess;
            o.allowSharedKeyAccess = allowSharedKeyAccess;
            o.azureFilesIdentityBasedAuthentication = azureFilesIdentityBasedAuthentication;
            o.blobRestoreStatus = blobRestoreStatus;
            o.creationTime = creationTime;
            o.customDomain = customDomain;
            o.enableHttpsTrafficOnly = enableHttpsTrafficOnly;
            o.enableNfsV3 = enableNfsV3;
            o.encryption = encryption;
            o.extendedLocation = extendedLocation;
            o.failoverInProgress = failoverInProgress;
            o.geoReplicationStats = geoReplicationStats;
            o.id = id;
            o.identity = identity;
            o.isHnsEnabled = isHnsEnabled;
            o.keyCreationTime = keyCreationTime;
            o.keyPolicy = keyPolicy;
            o.kind = kind;
            o.largeFileSharesState = largeFileSharesState;
            o.lastGeoFailoverTime = lastGeoFailoverTime;
            o.location = location;
            o.minimumTlsVersion = minimumTlsVersion;
            o.name = name;
            o.networkRuleSet = networkRuleSet;
            o.primaryEndpoints = primaryEndpoints;
            o.primaryLocation = primaryLocation;
            o.privateEndpointConnections = privateEndpointConnections;
            o.provisioningState = provisioningState;
            o.routingPreference = routingPreference;
            o.sasPolicy = sasPolicy;
            o.secondaryEndpoints = secondaryEndpoints;
            o.secondaryLocation = secondaryLocation;
            o.sku = sku;
            o.statusOfPrimary = statusOfPrimary;
            o.statusOfSecondary = statusOfSecondary;
            o.tags = tags;
            o.type = type;
            return o;
        }
    }
}
